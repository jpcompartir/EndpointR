---
title: "Structured Outputs - JSON Schema"
output: 
  html_document:
    toc: true
    toc_float: 
     collapsed: false
     smooth_scroll: true
    toc_depth: 3
    theme: flatly
    number_sections: true
    fig_caption: true
    df_print: paged
    highlight: tango
    code_folding: show
    anchor_sections: true
vignette: >
  %\VignetteIndexEntry{structured_outputs_json_Scchema}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE,
  message = FALSE,
  warning = FALSE,
  eval = TRUE
)
```

> **NOTE:** This vignette was generated by Claude 4 Sonnet, and then edited. The JSON Schema code was adapted by the same model. If you think your code was copied, or used by Sonnet, please let us know and we will credit accordingly.

```{r}
library(EndpointR)
library(S7)
library(cli)
library(jsonlite)
```

# Introduction to Structured Outputs

Structured outputs ensure LLMs return data in exactly the format you need. Instead of parsing messy text, you get validated JSON matching your schema.

**Why use structured outputs?** - eliminates parsing errors and inconsistent formats - guarantees data types (numbers vs strings, booleans vs text) - enables reliable data extraction pipelines - reduces prompt engineering overhead

**Basic workflow:** 1. define schema using helper functions 2. convert to API format with `json_dump()` 3. send to OpenAI with structured output enabled 4. validate response with `validate_response()`

# Quick Start

```{r, contract_schema}
contact_schema <- create_json_schema(
 name = "contact_info",
 schema = schema_object(
   name = schema_string("person's full name"),
   email = schema_string("email address"),
   phone = schema_string("phone number"),
   required = c("name")
 )
)

api_format <- json_dump(contact_schema)
```

Now view the schema:

```{r, contract_schema_print}
jsonlite::toJSON(api_format, 
                 pretty = TRUE, 
                 auto_unbox = TRUE)
```

Validate an object fits the schema:

```{r}
mock_contact <- list(
 name = "Jane Doe",
 email = "jane.doe@example.com",
 phone = "07123 456789"
)

mock_contact_json <- jsonlite::toJSON(mock_contact, auto_unbox = TRUE)

validate_response(contact_schema, mock_contact_json) |> 
  tibble::as_tibble()
```

## Basic Schema Creation

Core schema types handle most data extraction needs:

```{r, sentiment_schema}
# text classification with enums
sentiment_schema <- create_json_schema(
  name = "sentiment_analysis",
  schema = schema_object(
    sentiment = schema_enum(
      c("positive", "negative", "neutral"),
      "overall sentiment of text"
    ),
    confidence = schema_number(
      "confidence score", 
      minimum = 0, 
      maximum = 1
    ),
    keywords = schema_array(
      schema_string(),
      "key phrases from text",
      max_items = 5
    ),
    is_spam = schema_boolean("contains spam content"),
    required = c("sentiment", "confidence")
  )
)
```

Now view the schema:

```{r, sentiment_schema_print}
json_dump(sentiment_schema) |> 
  jsonlite::toJSON(pretty = TRUE, auto_unbox = TRUE)
```

Another, more complicated, schema for product review extraction:

```{r, customer_rating_schema}
rating_schema <- create_json_schema(
  name = "product_review",
  schema = schema_object(
    rating = schema_integer("star rating", minimum = 1, maximum = 5),
    title = schema_string("review title"),
    pros = schema_array(
      schema_string(),
      "positive aspects mentioned"
    ),
    cons = schema_array(
      schema_string(),
      "negative aspects mentioned"
    ),
    would_recommend = schema_boolean("recommends product"),
    required = c("rating")
  )
)
```

view the schema structure:

```{r, customer_rating_schema_dump}
json_dump(rating_schema) |> 
  jsonlite::toJSON(pretty = TRUE, auto_unbox = TRUE)
```

## Schema Types and Validation

Each schema type enforces specific constraints. We have a method for validating whether specific responses meet the schema's constraints.

Here's a comprehensive example:

```{r, user_profile_schema}
user_profile_schema <- create_json_schema(
 name = "user_profile",
 schema = schema_object(
   # string fields
   name = schema_string("full name"),
   bio = schema_string("user biography"),
   
   # numeric fields
   age = schema_integer("age in years", minimum = 13, maximum = 120),
   account_balance = schema_number("balance in pounds", minimum = 0),
   is_verified = schema_boolean("account verified status"),
   newsletter_opt_in = schema_boolean("subscribed to newsletter"),
   subscription_tier = schema_enum(
     c("free", "premium", "enterprise"),
     "subscription level"),
   priority = schema_enum(
     c(1, 2, 3),
     "support priority level",
     type = "integer"
   ),
   interests = schema_array(
     schema_string(),
     "user interests",
     min_items = 1,
     max_items = 10
   ),
   
   required = c("name", "age", "is_verified", "subscription_tier")
 )
)
```

## How Validation Works

When using structured outputs with LLM providers:

-   API-side enforcement: The provider ensures generated responses match your schema
-   Local validation: - validate_response() double-checks data integrity locally

This dual approach catches both generation errors and data transmission issues.

Now let's see what happens when we try validate a mocked response object:

```{r, valid_response}
valid_user <- '{
  "name": "Alice Smith",
  "age": 28,
  "account_balance": 156.75,
  "is_verified": true,
  "newsletter_opt_in": false,
  "subscription_tier": "premium",
  "priority": 2,
  "interests": ["data science", "functional programming", "statistics"]
}'

validated_data <- validate_response(user_profile_schema, valid_user)
str(validated_data)
```

And some invalid examples:

Here we should fail because the age needs to be 13 or above:

```{r invalid_age, error = TRUE}
invalid_age <- '{
  "name": "Young User",
  "age": 10,
  "is_verified": true,
  "subscription_tier": "free"
}'

validate_response(user_profile_schema, invalid_age)
```

Now an example which has an invalid enumerated value - tier must be one of "free", "premium", "enterprise":

```{r invalid_enum, error = TRUE}
invalid_tier <- '{
  "name": "Bob Jones",
  "age": 35,
  "is_verified": false,
  "subscription_tier": "platinum"
}'

validate_response(user_profile_schema, invalid_tier)
```

Now an example which fails due to too many interests (we should have a max of 10):

```{r invalid_length, error = TRUE}
invalid_interests <- list(
  name = "Data Enthusiast",
  age = 30,
  is_verified = TRUE,
  subscription_tier = "enterprise",
  interests = letters[1:15]  # 15 items exceeds max
)

validate_response(user_profile_schema, invalid_interests)

```

## Complex Nested Structures

In this section we'll create some fairly complex examples, to help build an intuition for what the schema objects can do:

```{r invoice_schema}
# invoice parsing with line items
invoice_schema <- create_json_schema(
  name = "invoice_data",
  schema = schema_object(
    # header information
    invoice_number = schema_string("invoice reference number"),
    issue_date = schema_string("date issued (YYYY-MM-DD format)"),
    due_date = schema_string("payment due date (YYYY-MM-DD format)"),
    # billing details
    supplier = schema_object(
      name = schema_string("supplier company name"),
      address = schema_string("supplier address"),
      vat_number = schema_string("VAT registration number"),
      required = c("name")
    ),
    customer = schema_object(
      name = schema_string("customer name"),
      address = schema_string("customer address"),
      required = c("name")
    ),
    # line items array
    line_items = schema_array(
      schema_object(
        description = schema_string("item description"),
        quantity = schema_integer("quantity ordered", minimum = 1),
        unit_price = schema_number("price per unit", minimum = 0),
        line_total = schema_number("total for this line", minimum = 0),
        required = c("description", "quantity", "unit_price", "line_total")
      ),
      "invoice line items",
      min_items = 1
    ),
    # totals
    subtotal = schema_number("subtotal before tax", minimum = 0),
    vat_amount = schema_number("VAT amount", minimum = 0),
    total_amount = schema_number("final total amount", minimum = 0),
    
    required = c("invoice_number", "supplier", "line_items", "total_amount")
  )
)
```

Another example with complex nesting:

```{r, research_paper_schema}
# research paper metadata extraction
paper_schema <- create_json_schema(
  name = "research_paper",
  schema = schema_object(
    title = schema_string("paper title"),
    abstract = schema_string("paper abstract"),
    
    authors = schema_array(
      schema_object(
        name = schema_string("author full name"),
        affiliation = schema_string("institutional affiliation"),
        email = schema_string("contact email"),
        required = c("name")
      ),
      "paper authors",
      min_items = 1
    ),
    
    keywords = schema_array(
      schema_string(),
      "research keywords",
      max_items = 10
    ),
    
    publication_year = schema_integer(
      "year published", 
      minimum = 1900, 
      maximum = 2025
    ),
    
    journal = schema_string("journal name"),
    doi = schema_string("digital object identifier"),
    
    methodology = schema_enum(
      c("experimental", "observational", "theoretical", "review", "meta-analysis"),
      "research methodology type"
    ),
    
    required = c("title", "authors", "publication_year")
  )
)

# demonstrate nested structure
json_dump(paper_schema) |>
  jsonlite::toJSON(pretty = TRUE, auto_unbox = TRUE) |>
  cat()
```

## Best Practices and Troubleshooting

Schema design principles:

-   Use descriptive field names and descriptions
-   Set appropriate constraints (min/max values, required fields)
-   Prefer enums over free text for categories
-   Nest objects logically for complex data
-   Validate some mock responses in advance

Common patterns:

Classification Schemas with space for model confidence scoring:

```{r, classification_schema}
# classification with confidence scores
classification_schema <- create_json_schema(
  name = "text_classification",
  schema = schema_object(
    predicted_class = schema_enum(
      c("spam", "promotional", "transactional", "personal"),
      "email category"
    ),
    confidence = schema_number(
      "prediction confidence",
      minimum = 0,
      maximum = 1
    ),
    reasoning = schema_string("explanation for classification"),
    required = c("predicted_class", "confidence")
  )
)
```

> **WARNING:** LLM's don't really know how confident they are, and their 'confidence scores' are NOT guaranteed to function as we would expect scores to function, i.e. they may not conform to transitivity (a \> b, b \> c -\> a \> c)

Data extraction with validation flags:

```{r, extraction_schema}
extraction_schema <- create_json_schema(
  name = "document_extraction",
  schema = schema_object(
    extracted_data = schema_object(
      company_name = schema_string("company name"),
      date = schema_string("document date"),
      amount = schema_number("monetary amount", minimum = 0)
    ),
    extraction_confidence = schema_enum(
      c("high", "medium", "low"),
      "confidence in extracted data"
    ),
    needs_human_review = schema_boolean("requires manual verification"),
    issues_found = schema_array(
      schema_string(),
      "extraction problems encountered"
    ),
    required = c("extracted_data", "extraction_confidence")
  )
)
```

## Troubleshooting tips:

-   use json_dump() to inspect final schema structure
-   test schemas with mock data using validate_response()
-   start simple and add complexity incrementally
-   check enum values match expected model outputs
-   validate required fields cover essential data
