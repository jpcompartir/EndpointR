% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/openai_completions.R
\name{oai_complete_df}
\alias{oai_complete_df}
\title{Process a data frame through OpenAI's Chat Completions API}
\usage{
oai_complete_df(
  df,
  text_var,
  id_var,
  model = "gpt-4.1-nano",
  system_prompt = NULL,
  schema = NULL,
  concurrent_requests = 1L,
  max_retries = 5L,
  timeout = 30,
  temperature = 0,
  max_tokens = 500L,
  progress = TRUE,
  key_name = "OPENAI_API_KEY",
  endpoint_url = "https://api.openai.com/v1/chat/completions"
)
}
\arguments{
\item{df}{Data frame containing text to process}

\item{text_var}{Column name (unquoted) containing text inputs}

\item{id_var}{Column name (unquoted) for unique row identifiers}

\item{model}{OpenAI model to use (default: "gpt-4.1-nano")}

\item{system_prompt}{Optional system prompt applied to all requests}

\item{schema}{Optional JSON schema for structured output (json_schema object or list)}

\item{concurrent_requests}{Number of simultaneous API requests (default: 1)}

\item{max_retries}{Maximum retry attempts per request (default: 5)}

\item{timeout}{Request timeout in seconds (default: 30)}

\item{temperature}{Sampling temperature (0-2), lower = more deterministic (default: 0)}

\item{max_tokens}{Maximum tokens per response (default: 500)}

\item{progress}{Show progress bar (default: TRUE)}

\item{key_name}{Environment variable name for API key (default: "OPENAI_API_KEY")}

\item{endpoint_url}{OpenAI API endpoint URL}
}
\value{
A tibble
}
\description{
This function takes a data frame with text inputs and processes each row through
OpenAI's Chat Completions API, returning results in a tidy format. It handles
concurrent requests, retries, and structured output validation automatically.
}
\details{
This function streamlines processing of data through OpenAI's API.
It extracts the specified text column from your data frame, sends each text as a
separate API request, and returns the results joined back to your original data.

The function preserves row identity through the \code{id_var} parameter, ensuring results
can be matched back to source data even if some requests fail. Failed requests are
marked with \code{.error = TRUE} and include error messages.

When using structured outputs with a \code{schema}, the function automatically validates
and unnests (to the top level) the JSON responses into separate columns. This makes it ideal for
tasks like entity extraction, classification, or structured data generation.

For best performance, adjust \code{concurrent_requests} based on your API rate limits.
Higher values speed up processing but may hit rate limits more frequently.
}
\examples{
\dontrun{

sample_texts <- rep("sample_text", 100)
# Parallel requests without schema:
large_df <- data.frame(
  doc_id = 1:100,
  text = sample_texts
)

results <- oai_complete_df(
  large_df,
  text_var = text,
  id_var = doc_id,
  concurrent_requests = 5,  # process 5 at a time
  max_retries = 3
)

# Structured outputs with a schema:
contact_schema <- create_json_schema(
 name = "contact_info",
 schema = schema_object(
  name = schema_string("person's full name"),
  email = schema_string("email address"),
  phone = schema_string("phone number"),
  required = list("name", "email", "phone"),
  additional_properties = FALSE
))

text <- "Am I speaking with Margaret Phillips?
Yes, ok, and your email is mphil@hotmail.co.uk.
Ok perfect, and your phone number? Was that 07564789789? Ok great.
Just a second please Margaret, you're verified"

schema_df <- data.frame(id = 1, text = text)

results <- oai_complete_df(
  schema_df,
  text_var = text,
  id_var = id,
  schema = contact_schema,
  temperature = 0  # recommended for structured outputs
)

}
}
