% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/openai_completions.R
\name{oai_complete_chunks}
\alias{oai_complete_chunks}
\title{Process text chunks through OpenAI's Chat Completions API with batch file output}
\usage{
oai_complete_chunks(
  texts,
  ids,
  chunk_size = 5000L,
  model = "gpt-4.1-nano",
  system_prompt = NULL,
  output_dir = "auto",
  schema = NULL,
  concurrent_requests = 5L,
  temperature = 0L,
  max_tokens = 500L,
  max_retries = 5L,
  timeout = 30L,
  key_name = "OPENAI_API_KEY",
  endpoint_url = "https://api.openai.com/v1/chat/completions",
  id_col_name = "id"
)
}
\arguments{
\item{texts}{Character vector of texts to process}

\item{ids}{Vector of unique identifiers corresponding to each text (same length as texts)}

\item{chunk_size}{Number of texts to process in each batch (default: 5000)}

\item{model}{OpenAI model to use (default: "gpt-4.1-nano")}

\item{system_prompt}{Optional system prompt applied to all requests}

\item{output_dir}{Path to directory for the .parquet chunks. "auto" generates a timestamped directory name. If NULL, uses a temporary directory.}

\item{schema}{Optional JSON schema for structured output (json_schema object or list)}

\item{concurrent_requests}{Integer; number of concurrent requests (default: 5)}

\item{temperature}{Sampling temperature (0-2), lower = more deterministic (default: 0)}

\item{max_tokens}{Maximum tokens per response (default: 500)}

\item{max_retries}{Maximum retry attempts per failed request (default: 5)}

\item{timeout}{Request timeout in seconds (default: 30)}

\item{key_name}{Name of environment variable containing the API key (default: OPENAI_API_KEY)}

\item{endpoint_url}{OpenAI API endpoint URL}

\item{id_col_name}{Name for the ID column in output (default: "id"). When called from oai_complete_df(), this preserves the original column name.}
}
\value{
A tibble containing all results with columns:
\itemize{
\item ID column (name specified by \code{id_col_name}): Original identifier from input
\item \code{content}: API response content (text or JSON string if schema used)
\item \code{.error}: Logical indicating if request failed
\item \code{.error_msg}: Error message if failed, NA otherwise
\item \code{.chunk}: Chunk number for tracking
}
}
\description{
This function processes large volumes of text through OpenAI's Chat Completions API
in configurable chunks, writing results progressively to parquet files. It handles
concurrent requests, automatic retries, and structured outputs while
managing memory efficiently for large-scale processing.
}
\details{
This function is designed for processing large text datasets that may not
fit comfortably in memory. It divides the input into chunks, processes each chunk
with concurrent API requests, and writes results immediately to disk to minimise
memory usage.

The function preserves data integrity by matching results to source texts through
the \code{ids} parameter. Each chunk is processed independently with results written as
parquet files to the output directory, allowing for resumable processing if interrupted.

When using structured outputs with a \code{schema}, responses are validated against
the JSON schema but stored as raw JSON strings in the output files. This allows
for flexible post-processing without memory constraints during the API calls.

The chunking strategy balances API efficiency with memory management. Larger
\code{chunk_size} values reduce overhead but increase memory usage. Adjust based on
your system resources and text sizes.

Avoid risk of data loss by setting a low-ish chunk_size (e.g. 5,000, 10,000). Each chunk is written to a \code{.parquet} file in the \verb{output_dir=} directory, which also contains a \code{metadata.json} file which tracks important information such as the model and endpoint URL used. Be sure to add output directories to .gitignore!
}
\examples{
\dontrun{
# basic usage with automatic directory naming:
result <- oai_complete_chunks(
  texts = my_texts,
  ids = my_ids,
  model = "gpt-4.1-nano"
)

# large-scale processing with custom output directory:
result <- oai_complete_chunks(
  texts = my_texts,
  ids = my_ids,
  output_dir = "my_results",
  chunk_size = 10000
)

# structured extraction with schema:
result <- oai_complete_chunks(
  texts = my_texts,
  ids = my_ids,
  schema = my_schema,
  temperature = 0
)

# post-process structured results:
processed <- result |>
  dplyr::filter(!.error) |>
  dplyr::mutate(parsed = purrr::map(content, ~jsonlite::fromJSON(.x))) |>
  tidyr::unnest_wider(parsed)
}
}
