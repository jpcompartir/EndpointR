% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/openai_completions.R
\name{oai_complete_chunks}
\alias{oai_complete_chunks}
\title{Process text chunks through OpenAI's Chat Completions API with batch file output}
\usage{
oai_complete_chunks(
  texts,
  ids,
  chunk_size = 5000L,
  model = "gpt-4.1-nano",
  system_prompt = NULL,
  output_file = "auto",
  schema = NULL,
  concurrent_requests = 5L,
  temperature = 0L,
  max_tokens = 500L,
  max_retries = 5L,
  timeout = 30L,
  key_name = "OPENAI_API_KEY",
  endpoint_url = "https://api.openai.com/v1/chat/completions"
)
}
\arguments{
\item{texts}{Character vector of texts to process}

\item{ids}{Vector of unique identifiers corresponding to each text (same length as texts)}

\item{chunk_size}{Number of texts to process in each batch (default: 5000)}

\item{model}{OpenAI model to use (default: "gpt-4.1-nano")}

\item{system_prompt}{Optional system prompt applied to all requests}

\item{output_file}{Path to .CSV file for results. "auto" generates the filename, location and is persistent across sessions. If NULL, generates timestamped filename.}

\item{schema}{Optional JSON schema for structured output (json_schema object or list)}

\item{concurrent_requests}{Integer; number of concurrent requests (default: 5)}

\item{temperature}{Sampling temperature (0-2), lower = more deterministic (default: 0)}

\item{max_tokens}{Maximum tokens per response (default: 500)}

\item{max_retries}{Maximum retry attempts per failed request (default: 5)}

\item{timeout}{Request timeout in seconds (default: 30)}

\item{key_name}{Name of environment variable containing the API key (default: OPENAI_API_KEY)}

\item{endpoint_url}{OpenAI API endpoint URL}
}
\value{
A tibble containing all results with columns:
\itemize{
\item \code{id}: Original identifier from input
\item \code{content}: API response content (text or JSON string if schema used)
\item \code{.error}: Logical indicating if request failed
\item \code{.error_msg}: Error message if failed, NA otherwise
\item \code{.batch}: Batch number for tracking
}
}
\description{
This function processes large volumes of text through OpenAI's Chat Completions API
in configurable chunks, writing results progressively to a CSV file. It handles
concurrent requests, automatic retries, and structured outputs while
managing memory efficiently for large-scale processing.
}
\details{
This function is designed for processing large text datasets that may not
fit comfortably in memory. It divides the input into chunks, processes each chunk
with concurrent API requests, and writes results immediately to disk to minimise
memory usage.

The function preserves data integrity by matching results to source texts through
the \code{ids} parameter. Each chunk is processed independently with results appended
to the output file, allowing for resumable processing if interrupted.

When using structured outputs with a \code{schema}, responses are validated against
the JSON schema but stored as raw JSON strings in the output file. This allows
for flexible post-processing without memory constraints during the API calls.

The chunking strategy balances API efficiency with memory management. Larger
\code{chunk_size} values reduce overhead but increase memory usage. Adjust based on
your system resources and text sizes.
}
\examples{
\dontrun{
# Basic usage with automatic file naming
texts <- c("Great product!", "Awful service.", "Decent value.")
ids <- c("review_1", "review_2", "review_3")

results <- oai_complete_chunks(
  texts = texts,
  ids = ids,
  system_prompt = "Classify sentiment as positive, negative, or neutral."
)

# Large-scale processing with custom output file
results <- oai_complete_chunks(
  texts = large_text_vector,
  ids = seq_along(large_text_vector),
  chunk_size = 2000,
  concurrent_requests = 10,
  output_file = "data/sentiment_results.csv"
)

# Structured extraction with schema
sentiment_schema <- create_json_schema(
  name = "sentiment_analysis",
  schema = schema_object(
    sentiment = schema_string("positive, negative, or neutral"),
    confidence = schema_number("confidence score between 0 and 1"),
    required = list("sentiment", "confidence")
  )
)

results <- oai_complete_chunks(
  texts = texts,
  ids = ids,
  schema = sentiment_schema,
  temperature = 0
)

# Post-process structured results
results |>
  dplyr::filter(!.error) |>
  dplyr::mutate(parsed = purrr::map(content, safely_from_json)) |>
  tidyr::unnest_wider(parsed)
}
}
